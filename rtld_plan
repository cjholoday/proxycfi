Timeline:
    1. calls into "basic" shared libraries work. "basic" shared libraries
       do not have function pointer calls. 
    2. The verifier is run after the loader is finished
    3. Function pointer call support added for shared libraries
    4. PLT entries are fixed up at load time so that the calls are direct

Responsibilities
----------------
converter
    (1) Generate a dummy SLT trampoline. Entries contain a relative jump back 
        to the function they are serving. This allows us to associate symbols
        with trampoline entries. The trampolines will be changed to point to 
        SLT entries at load time
    (1) Generate an empty trampoline info table that is an array corresponding 
        to the SLT trampoline table. Each array element will eventually be filled
        with the symbol table index of the trampoline's associated symbol. For now,
        the array elements are left empty until cdi-ld fills them in
    (1) write null 4 byte addresses before RLT entries. These will be filled 
        to contain the addresses of each RLT entry's associated PLT return 
        address
    (3) expand the SLT trampoline to hold entries for fptr sleds. 
    (3) Create a .typestrtab section, which has its types lexicographically sorted

cdi-ld
    (1) Fill the SLT trampoline info table with symbol table indices. 
    (1) Add function multiplicity information to the executable
    (1) Overwrite the PLT entries to have an indirect CALL
    (1) Associate PLT entry return addresses with RLT entries. Use PLT relocs
        to identify the symbol name. Then use symbol name to get the RLT entry
        by looking through the symbol table
    (4) Overwrite shared lib PLT entries to jump down to an unshared PLT

rtld
    (1) identify the cdi metadata added onto each shared lib
    (1) for each shared lib, calculate the extra space needed for the SLT
    (1) mmap extra space for the SLT
    (1) build the SLTs by iterating through the SLT trampoline. Each SLT 
        has an associated symbol name, which can be used with the symtab hash
        table to get RLT entries. Check each code object if it has an RLT entry
        until the multiplicity is satisfied. Each RLT entry will have an associated
        PLT return address which should be used to validate jumps in SLTs
    (2) Modify verifier to work with segments, SLTs, RLTs, and modified PLTs
    (4) Fixup unshared PLT entries to be direct using the global offset table


ELF CDI section
    function multiplicity
    ftypes/fptypes information

-----------------------------------------------------------
Name           | Size | Align | Purpose
-----------------------------------------------------------
Elf64_Addr       8      8       Unsigned program address
Elf64_Off        8      8       Unsigned file offset 
Elf64_Half       2      2       Unsigned medium integer
Elf64_Word       4      4       Unsigned integer
Elf64_Sword      4      4       Signed integer
Elf64_Xword      8      8       Unsigned long integer
Elf64_Sxword     8      8       Signed long integer 
unsigned char    1      1       Unsigned small integer

=========================================================================

typedef struct {
    Elf64_Word cdi_ident;
    Elf64_Word num_sshdrs;
    Elf64_Word sshtab_addr;
    Elf64_Word unused;
}

cdi_ident: an identifier used to mark the remaining file as CDI metadata
num_sshdrs: the number of subsection headers in the .cdi_sshtab subsection
sshtab_addr: gives the address of the first byte of the .cdi_sshtab subsection

=========================================================================
Subsection .cdi_sshtab

typedef struct {
    Elf64_Word ssh_name;
    Elf64_Word ssh_size;
    Elf64_Word ssh_addr;
    Elf64_Half ssh_type;
    unsigned char ssh_align;
    unsigned char unused;
} CDI_Sshdr

ssh_name: an index into the cdi_strtab
ssh_size: the section's size in bytes
ssh_addr: the address at which the subsection's first byte should reside
ssh_type: categorizes the type of CDI subsection see below for a table
ssh_align: indicates that this subsection needs to be aligned by a certain power
           of two bytes. It is calculated as (1 << ssh_align). ssh_align must be
           smaller than or equal to six

ssh_type | Meaning
---------+---------------
0        | No type 
1        | cdi strtab subsection
2        | multiplicity subsection
< 2^16   | undefined

=========================================================================
Subsection .cdi_mult

typedef struct {
    Elf64_Word soname;
    Elf64_Word total_multiplicity;
    Elf64_Word num_global_syms;
    Elf64_Word unused;
    typedef struct {
        Elf64_Word sym_name;
        Elf64_Word multiplicity;
    } Elf64_CDI_Sym_Mult[num_global_syms];
} Elf64_CDI_Mult[NUM_SHARED_LIBS]

soname: contains an index into the CDI string table for the shared library's soname
total_multiplicity: the total multiplicity of all global symbols for this shared library
num_global_syms: the total number of global symbols in this shared library
sym_name: an index into the cdi_strtab
multiplicity: The number of distinct code objects that call sym_name. Code objects
              include the executable and any shared libraries. A call to sym_name
              from within its own shared library is counted in the multiplicity.
              The multiplicity is used to construct the size of the SLT

This subsection is only needed for shared libraries since it's only purpose is 
to facilitate calculating the SLT size at load time. Executables do not have an 
SLT since shared libraries cannot call into an executable without using a function
pointer.
