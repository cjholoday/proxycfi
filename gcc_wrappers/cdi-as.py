#!/usr/bin/env python

import __init__
import sys
import subprocess
import os
import re
from common.eprint import eprint

AS_ARG_REQUIRED_OPTIONS = ['--debug-prefix-map', '--defsym', '-I', '-o']

class MissingDependency(Exception):
    def __init__(self, dep_list):
        self.dep_list = dep_list

# returns (input assembly filename, output object filename, cdi spec version)
def parse_as_spec(spec):
    output_obj_fname = ''
    input_asm_fname = ''
    prev_word = ''
    as_spec_no_io = ''
    for word in spec.split():
        is_io = False
        if prev_word == '-o':
            assert output_obj_fname == ''
            output_obj_fname = word
            is_io = True
        elif prev_word not in AS_ARG_REQUIRED_OPTIONS and word[0] != '-':
            input_asm_fname = word
            is_io = True
        elif word == '-o':
            is_io = True
        prev_word = word
        if not is_io:
            as_spec_no_io += word + ' '

    if output_obj_fname == '':
        output_obj_fname = 'a.out'

    return input_asm_fname, output_obj_fname, as_spec_no_io

# Returns a list of dependencies (.c and .h filenames)
def get_dependencies(fname):
    source_fnames = []
    header_fnames = []
    is_debug_mode = False
    dwarf_file_matcher = re.compile(r'^\t.file [0-9]+ ".*"$')
    with open(input_asm_fname, 'r') as asm:
        for line in asm:
            if dwarf_file_matcher.match(line):
                is_debug_mode = True
                fname = line.split()[2].strip('"')
                if fname.endswith('.h'):
                    header_fnames.append(fname)
                else:
                    source_fnames.append(fname)

    if not is_debug_mode:
        eprint("cdi-as: warning: debug mode is disabled. Use '--save-temps', '-g',"
                " and '-fno-jump-tables' when compiling with CDI")

    return (source_fnames, header_fnames)

def absolute_directory(fname_path):
    fname_index = fname_path.rfind('/') + 1
    if fname_index == 0:
        return os.getcwd()
    elif fname_path[0] == '/':
        return fname_path[:fname_index - 1]
    
    dir_path = os.getcwd() + '/' + fname_path[:fname_index - 1]
    return os.path.realpath(dir_path)


########################################################################
# cdi-as: a cdi wrapper for the gnu assembler 'as'
#   creates fake object files
#
#   fake object files contain all the information necessary to create a real
#   cdi-compliant object file. 
#       1) as spec
#       2) source directory
#       3) type information
#       4) assembly
#
#   While the source directory is not strictly needed, it's valuable information
#   that can help recover from errors. For example, suppose a dependency's
#   ftypes file is not found in cdi-as because the dependency is autogenerated.
#   Once cdi-ld obtains control, it can look back for the autogenerated 
#   dependency's ftype file 
#
#   for more information, see the documentation
########################################################################



as_spec = ' '.join(sys.argv[1:])
input_asm_fname, output_obj_fname, as_spec_no_io = parse_as_spec(as_spec)
input_src_fname_stem = input_asm_fname[:input_asm_fname.rfind('.')]
fake_object = open(output_obj_fname, 'w')

# support hardcoded typeinfo

hardcoded_typeinfo = ''
with open(input_asm_fname, 'r') as input_asm:
    first_line = input_asm.readline()
    if first_line == '# hardcoded_typeinfo\n':
        line = ''
        while line != '# assembly\n':
            hardcoded_typeinfo += line
            line = input_asm.readline()
            if line == '':
                eprint("cdi-as: error: unterminated hardcoded typeinfo section found")
                sys.exit(1)


fake_object.write('#<deff>\n')
fake_object.write('# as_spec ' + as_spec + '\n')
fake_object.write('# as_spec_no_io ' + as_spec_no_io + '\n')
fake_object.write('# source_directory {}\n'.format(absolute_directory(
    input_asm_fname)))

# Be nice and check that the user enabled option --save-temps
if input_asm_fname.startswith('/tmp/'):
    eprint("cdi-as: error: assembly file is temporary. Use '--save-temps', '-g',"
            " and '-fno-jump-tables' when compiling with CDI")
    sys.exit(1)

source_deps, header_deps = get_dependencies(input_asm_fname)

fake_object.write('# dependencies ' + ' '.join(source_deps) + ' ' + ' '.join(header_deps) + '\n')

# find the function and function pointer type information from dependencies
# and place them in the fake object file
for dep_fname in source_deps + header_deps:
    dep_used = False
    if os.path.isfile(dep_fname + '.ftypes'):
        ftypes = open(dep_fname + '.ftypes', 'r') 
        dep_used = True
        fake_object.write('# typeinfo ' + dep_fname + '.ftypes\n')
        contents = ftypes.read()
        while contents and contents[-1] == '\n':
            contents = contents[:-1]
        if len(contents) > 0:
            fake_object.write('# ' + contents.replace('\n', '\n# ') + '\n\n')
        ftypes.close()

    if os.path.isfile(dep_fname + '.fptypes'):
        fptypes = open(dep_fname + '.fptypes', 'r') 
        dep_used = True
        fake_object.write('# typeinfo ' + dep_fname + '.fptypes\n')
        contents = fptypes.read()
        while contents and contents[-1] == '\n':
            contents = contents[:-1]
        if len(contents) > 0:
            fake_object.write('# ' + contents.replace('\n', '\n# ') + '\n\n')
        else:
            fake_object.write('\n')
        fptypes.close()

    if not dep_used:
        # We refrain from omitting this to output since it has yet to be useful
        fake_object.write('# warning no_type_info {}\n'.format(dep_fname))

fake_object.write(hardcoded_typeinfo)
fake_object.write('# assembly\n')

# write the input assembly over to the fake object file.
with open(input_asm_fname, 'r') as input_asm:
    if first_line == '# hardcoded_typeinfo\n':
        line = ''
        while line != '# assembly\n':
            line = input_asm.readline()
    fake_object.write(''.join(input_asm.readlines()))
