#!/usr/bin/env python
import sys
import subprocess
import os
from eprint import eprint

AS_ARG_REQUIRED_OPTIONS = ['--debug-prefix-map', '--defsym', '-I', '-o']

class MissingDependency(Exception):
    def __init__(self, dep_list):
        self.dep_list = dep_list

# returns (input assembly filename, output object filename, cdi spec version)
def parse_as_spec(spec):
    output_obj_fname = ''
    input_asm_fname = ''
    prev_word = ''
    as_spec_no_io = ''
    for word in spec.split():
        is_io = False
        if prev_word == '-o':
            assert output_obj_fname == ''
            output_obj_fname = word
            is_io = True
        elif prev_word not in AS_ARG_REQUIRED_OPTIONS and word[0] != '-':
            input_asm_fname = word
            is_io = True
        elif word == '-o':
            is_io = True
        prev_word = word
        if not is_io:
            as_spec_no_io += word + ' '

    if output_obj_fname == '':
        output_obj_fname = 'a.out'

    return input_asm_fname, output_obj_fname, as_spec_no_io

# Returns a list of dependencies of a .c source file
# the source file itself is included in the list
def get_dependencies(fname):
    # Remove GCC_EXEC_PREFIX from the environment for normal gcc
    # This allows normal gcc to find the programs it needs
    try:
        normal_gcc_env = os.environ.copy()
        del normal_gcc_env['GCC_EXEC_PREFIX']
    except KeyError:
        pass

    try:
        # gcc may append '\' at the end of lines. don't return them
        raw_dep_list = subprocess.check_output(['gcc', '-MM', fname],
                stderr=subprocess.STDOUT, env=normal_gcc_env
                ).split()[1:]
        return [dep for dep in raw_dep_list if dep != '\\']
    except subprocess.CalledProcessError as err:
        raw_dep_list = subprocess.check_output(['gcc', '-MM', '-MG',
            fname], env=normal_gcc_env).split()[1:]
        raise MissingDependency([dep for dep in raw_dep_list if dep != '\\'])

def absolute_directory(fname_path):
    fname_index = fname_path.rfind('/') + 1
    if fname_index == 0:
        return os.getcwd()
    elif fname_path[0] == '/':
        return fname_path[:fname_index - 1]
    
    dir_path = os.getcwd() + '/' + fname_path[:fname_index - 1]
    return os.path.realpath(dir_path)


########################################################################
# cdi-as: a cdi wrapper for the gnu assembler 'as'
#   creates fake object files
#
#   fake object files contain all the information necessary to create a real
#   cdi-compliant object file. 
#       1) as spec
#       2) source directory
#       3) type information
#       4) assembly
#
#   While the source directory is not strictly needed, it's valuable information
#   that can help recover from errors. For example, suppose a dependency's
#   ftypes file is not found in cdi-as because the dependency is autogenerated.
#   Once cdi-ld obtains control, it can look back for the autogenerated 
#   dependency's ftype file 
#
#   for more information, see the documentation
########################################################################



as_spec = ' '.join(sys.argv[1:])
input_asm_fname, output_obj_fname, as_spec_no_io = parse_as_spec(as_spec)
input_src_fname_stem = input_asm_fname[:input_asm_fname.rfind('.')]
fake_object = open(input_src_fname_stem + '.o', 'w')

fake_object.write('#<deff>\n')
fake_object.write('# as_spec ' + as_spec + '\n')
fake_object.write('# as_spec_no_io ' + as_spec_no_io + '\n')
fake_object.write('# source_directory {}\n'.format(absolute_directory(
    input_asm_fname)))

# Are we using C or C++? 
if os.path.isfile(input_src_fname_stem + '.c'):
    language = 'c'
    if os.path.isfile(input_src_fname_stem + '.cpp'):
        eprint("cdi-as: warning: '{}' and '{}' are both present. Assuming "
                "language is C".format(input_src_fname_stem + '.c',
                    input_src_fname_stem + '.cpp'))

elif os.path.isfile(input_src_fname_stem + '.cpp'):
    language = 'cpp'
else:
    fake_object.write('# warning source_file_missing\n')
    eprint("cdi-as: error: source file for '" + input_asm_fname + "' cannot "
            "be found")
    sys.exit(1)

try:
    deps = get_dependencies(input_src_fname_stem + '.' + language)
except MissingDependency as err:
    deps = err.dep_list
    fake_object.write('# warning missing_dependency\n')
    eprint("cdi-as: warning: missing dependency associated with '" + 
        input_src_fname_stem + '.' + language)

fake_object.write('# dependencies ' + ' '.join(deps) + '\n')

# find the function and function pointer type information from dependencies
# and place them in the fake object file
for dep_fname in deps:
    dep_used = False
    if os.path.isfile(dep_fname + '.ftypes'):
        ftypes = open(dep_fname + '.ftypes', 'r') 
        dep_used = True
        fake_object.write('# typeinfo ' + dep_fname + '.ftypes\n')
        contents = ftypes.read()
        while contents and contents[-1] == '\n':
            contents = contents[:-1]
        if len(contents) > 0:
            fake_object.write('# ' + contents.replace('\n', '\n# ') + '\n\n')
        ftypes.close()

    if os.path.isfile(dep_fname + '.fptypes'):
        fptypes = open(dep_fname + '.fptypes', 'r') 
        dep_used = True
        fake_object.write('# typeinfo ' + dep_fname + '.fptypes\n')
        contents = fptypes.read()
        while contents and contents[-1] == '\n':
            contents = contents[:-1]
        if len(contents) > 0:
            fake_object.write('# ' + contents.replace('\n', '\n# ') + '\n\n')
        else:
            fake_object.write('\n')
        fptypes.close()

    if not dep_used:
        eprint("cdi-as: warning: no ftypes/fptypes found with: '" + dep_fname + "'")
        fake_object.write('# warning no_type_info {}\n'.format(dep_fname))

fake_object.write('# assembly\n')
with open(input_asm_fname, 'r') as asm:
    fake_object.write(asm.read())

